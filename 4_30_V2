import pandas as pd
from geopy.geocoders import Nominatim
from math import radians, sin, cos, sqrt, atan2
import time
import os

geolocator = Nominatim(user_agent="offline_tsp")

# intro
def print_intro():
    print("""tsp_optimizer.py: Offline Route Optimizer
Overview
This is a simple tool for planning travel routes between cities in the United States. It uses a popular method called the Nearest Neighbor heuristic to estimate the shortest round-trip route.

What it Does
Calculates travel distance between cities using the Haversine formula, which measures distances on Earth using latitude and longitude.
Lets you choose between:
Interactive mode – You enter city names yourself.
Fixed list mode – Uses a built-in list of 20 major U.S. cities.

How to Use
Run the program in a Python environment.
Choose a mode:
Press 1 for interactive mode (add cities manually).
Press 2 to use all 20 preloaded cities automatically.
Choose which city to start from.
The tool will print:
An ordered list of travel steps.
Distance between each step.
Total distance of the full loop (in miles).

Disclaimer
- This program does not use maps or the internet (except for geocoding if you use interactive mode).
- It does not find the perfect route—just a good one based on proximity.
- This tool uses the Nearest Neighbor heuristic, which does not guarantee the optimal route.
- Geocoding (in Interactive mode) depends on an online service and may occasionally return inaccurate results.
- This is meant for educational or rough planning purposes, not for real world navigation or logistics.""")

# haversine
def haversine(lat1, lon1, lat2, lon2):
    R = 3958.8  # Earth radius in miles
    dlat = radians(lat2 - lat1)
    dlon = radians(lon2 - lon1)
    a = sin(dlat/2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    return R * c

# load saved list

# city management
def manage_city_list():
    cities = []

    while True:
        if os.path.exists("city_list.csv"):
            choice = input("1. New List\n2. Load Saved List\nChoose: ")
            if choice not in ["1", "2"]:
                print("Retry")
                continue
        else:
            choice = "1"

        if choice == "2":
            df = pd.read_csv("city_list.csv")
            cities = df.to_dict('records')
            print("Loaded saved city list.")
        break

    while True:
        print("\nCurrent City List:")
        for i, c in enumerate(cities):
            print(f"{i+1}. {c['name']}")

        action = input("1. Add City\n2. Remove City\n3. Continue\nChoose: ")

        if action == "1":
            name = input("Enter city (City, State): ")
            try:
                location = geolocator.geocode(name, timeout=10)
                if not location:
                    print("Could not find coordinates.")
                    continue
                city = {"name": name, "lat": location.latitude, "lon": location.longitude}
                cities.append(city)
                print(f"Added {name} → ({location.latitude}, {location.longitude})")
            except Exception as e:
                print("Error fetching coordinates:", e)
            time.sleep(1)

        elif action == "2":
            idx = int(input("Enter city number to remove: ")) - 1
            if 0 <= idx < len(cities):
                removed = cities.pop(idx)
                print(f"Removed {removed['name']}")
            else:
                print("Invalid index.")

        elif action == "3":
            save = input("Save this list to city_list.csv? (y/n): ")
            if save.lower() == 'y':
                pd.DataFrame(cities).to_csv("city_list.csv", index=False)
                print("Saved.")
            break

    return cities

# solver
def solve_tsp(cities, start_idx=0, end_idx=None):
    n = len(cities)
    visited = [False] * n
    route = [start_idx]
    visited[start_idx] = True
    if end_idx is not None:
        visited[end_idx] = False  # don't mark end city visited yet

    total_distance = 0

    while len(route) < n - (1 if end_idx is not None else 0):
        last = route[-1]
        nearest = None
        min_dist = float('inf')
        for i in range(n):
            if not visited[i] and i != end_idx:
                dist = haversine(cities[last]['lat'], cities[last]['lon'],
                                 cities[i]['lat'], cities[i]['lon'])
                if dist < min_dist:
                    min_dist = dist
                    nearest = i
        visited[nearest] = True
        route.append(nearest)
        total_distance += min_dist

    if end_idx is not None:
        dist = haversine(cities[route[-1]]['lat'], cities[route[-1]]['lon'],
                         cities[end_idx]['lat'], cities[end_idx]['lon'])
        route.append(end_idx)
        total_distance += dist
    else:
        total_distance += haversine(
            cities[route[-1]]['lat'], cities[route[-1]]['lon'],
            cities[start_idx]['lat'], cities[start_idx]['lon']
        )
        route.append(start_idx)

    return route, total_distance

# ----------------- Output Table ------------------
def print_route(cities, route):
    print("\nOptimal Route (Nearest Neighbor Approximation):")
    print(f"{'City A':25} | {'City B':25} | {'Distance (mi)':>14}")
    print("-" * 70)
    for i in range(len(route) - 1):
        a = cities[route[i]]
        b = cities[route[i + 1]]
        dist = haversine(a['lat'], a['lon'], b['lat'], b['lon'])
        print(f"{a['name'][:25]:25} | {b['name'][:25]:25} | {dist:14.1f}")

# main
def main():
    print_intro()
    print("\nWelcome to the Offline Route Optimizer!")
    cities = manage_city_list()
    if len(cities) < 2:
        print("You need at least 2 cities.")
        return

    print("\nSelect starting city:")
    for i, c in enumerate(cities):
        print(f"{i+1}. {c['name']}")
    start_idx = int(input("Enter number: ")) - 1

    print("\nSelect ending city:")
    for i, c in enumerate(cities):
        print(f"{i+1}. {c['name']}")
    end_idx = int(input("Enter number: ")) - 1

    if end_idx == start_idx:
        print("End city must be different from start city for one-way trip.")
        return

    route, total = solve_tsp(cities, start_idx, end_idx)
    print_route(cities, route)
    print(f"\nEstimated Total Distance: {total:.1f} mi")

    save = input("Save results to CSV? (y/n): ")
    if save.lower() == 'y':
        records = []
        for i in range(len(route) - 1):
            a = cities[route[i]]
            b = cities[route[i + 1]]
            dist = haversine(a['lat'], a['lon'], b['lat'], b['lon'])
            records.append({
                "City A": a['name'],
                "City B": b['name'],
                "Distance (mi)": round(dist, 1)
            })
        pd.DataFrame(records).to_csv("route_output.csv", index=False)
        print("Saved as route_output.csv")

main()
